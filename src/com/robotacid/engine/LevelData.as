package com.robotacid.engine {
	import flash.geom.Point;
	import flash.geom.Rectangle;
	/**
	 * Manipulates templates generated by the Room class to conduct a game
	 * 
	 * The properties of elements can be examined to deduce what animations took place
	 * (see Level)
	 * 
	 * logic at this tier should remain architecture independant for portability
	 * 
	 * @author Aaron Steed, robotacid.com
	 */
	public class LevelData {
		
		public var room:Room;
		public var active:Boolean;
		public var player:Point;
		public var playerDir:int;
		public var oldPlayerX:int;
		public var oldPlayerY:int;
		public var width:int;
		public var height:int;
		public var map:Array/*Array*/;
		public var copyBuffer:Array/*Array*/;
		public var killCallback:Function;
		public var pushCallback:Function;
		public var swapCallback:Function;
		public var generateCallback:Function;
		public var displaceCallback:Function;
		public var endingCallback:Function;
		public var blockedCallback:Function;
		public var playerPush:Point;
		public var allies:Array/*Point*/;
		public var enemies:Array/*Point*/;
		public var doorOpened:Point;
		public var food:int;
		public var turns:int;
		public var ended:Boolean;
		
		public static var pathMap:Array;
		public static var initialised:Boolean;
		
		public static const ENEMY_ACTIVE_RADIUS:int = 5;
		public static const PATH_MAP_SIZE:int = 1 + ENEMY_ACTIVE_RADIUS * 2;
		public static const PATH_WALL:int = int.MAX_VALUE;
		public static const FOOD_MAX:int = 48;
		public static const FOOD_KILL:int = 8;
		
		// temp
		private var p:Point;
		
		public function LevelData(room:Room, width:int, height:int) {
			this.room = room;
			player = new Point(room.startX, room.startY);
			this.width = width;
			this.height = height;
			map = Room.create2DArray(width, height, Room.VOID);
			copyBuffer = Room.create2DArray(room.width, room.height, Room.VOID);
			room.copyTo(map, 0, 0);
			map[player.y][player.x] = Room.PLAYER | Room.ALLY;
			food = FOOD_MAX;
			active = true;
			allies = [];
			enemies = [];
			turns = 0;
		}
		
		public static function init():void{
			initialised = true;
			Room.init();
			pathMap = Room.create2DArray(1 + ENEMY_ACTIVE_RADIUS * 2, 1 + ENEMY_ACTIVE_RADIUS * 2, PATH_WALL);
		}
		
		public function playerTurn(dir:int):void{
			playerDir = dir;
			// flush player status first, then clear the map for the enemies after the player has moved
			map[player.y][player.x] &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.ATTACK | Room.BLOCKED | Room.PUSHED);
			oldPlayerX = player.x;
			oldPlayerY = player.y;
			player = move(player.x, player.y, playerDir, Room.ALLY);
			// a new room may have been created, or the player may have been pushed
			if(playerPush){
				player.x += playerPush.x;
				player.y += playerPush.y;
				oldPlayerX += playerPush.x;
				oldPlayerY += playerPush.y;
				playerPush = null;
			}
			var playerProperty:int = map[player.y][player.x];
			var swapProperty:int = map[oldPlayerY][oldPlayerX];
			flushStatus(player.x, player.y, ENEMY_ACTIVE_RADIUS + 2);
			// reload player behaviour and swapped position behaviour
			map[player.y][player.x] = playerProperty;
			if(swapProperty & Room.SWAP) map[oldPlayerY][oldPlayerX] = swapProperty & ~(Room.ATTACK | Room.BLOCKED);
			if(!(map[player.y][player.x] & Room.BLOCKED)){
				turns++;
				food--;
				allies.length = enemies.length = 0;
				// entities need to act based on their distance to the player - hence we used the pathMap
				fillPathMap(player.x, player.y, null, Room.ALLY, allies);
				moveEntities(allies);
			}
		}
		
		public function enemyTurn():void{
			enemies.length = allies.length = 0;
			// entities need to act based on their distance to the player - hence we used the pathMap
			fillPathMap(player.x, player.y, null, Room.ALLY, allies);
			allies.push(player); // path map ignores the starting square
			fillPathMap(player.x, player.y, allies.slice(), Room.ENEMY, enemies, Room.DOOR);
			moveEntities(enemies);
			// the player turns to stone (swap block) when out of food
			if((map[player.y][player.x] & Room.PLAYER) && food == 0) map[player.y][player.x] = Room.SWAP | Room.WALL;
		}
		
		/* Call to execute an entire turn without animation */
		public function fullTurn(dir:int):void{
			playerTurn(dir);
			if(!(map[player.y][player.x] & Room.BLOCKED)){
				enemyTurn();
			}
		}
		
		/* Player exists and is not surrounded by walls */
		public function alive():Boolean{
			return ended || Boolean(
				(map[player.y][player.x] & Room.PLAYER) && !(
					(player.y == 0 || ((map[player.y - 1][player.x] & (Room.WALL | Room.VOID)) && !(map[player.y - 1][player.x] & Room.SWAP))) &&
					(player.x == width - 1 || ((map[player.y][player.x + 1] & (Room.WALL | Room.VOID)) && !(map[player.y][player.x + 1] & Room.SWAP))) &&
					(player.y == height - 1 || ((map[player.y + 1][player.x] & (Room.WALL | Room.VOID)) && !(map[player.y + 1][player.x] & Room.SWAP))) &&
					(player.x == 0 || ((map[player.y][player.x - 1] & (Room.WALL | Room.VOID)) && !(map[player.y][player.x - 1] & Room.SWAP)))
				) &&
				food > 0
			);
		}
		
		/* Check if moving into a given square means being attacked - assumes the square is empty */
		public function getCheck(x:int, y:int):Boolean{
			return Boolean(
				(y > 0 && (map[y - 1][x] & Room.ENEMY) && (
					(
						(map[y - 1][x] & Room.TURNER) && (map[y - 1][x] & Room.DOWN)
					) || (
						(map[y - 1][x] & (Room.TRAP | Room.MOVER)) && (map[y - 1][x] & Room.M_DOWN)
					)
				) && !(map[y - 1][x] & (Room.GENERATOR | Room.VIRUS))) ||
				(x < width - 1 && (map[y][x + 1] & Room.ENEMY) && (
					(
						(map[y][x + 1] & Room.TURNER) && (map[y][x + 1] & Room.LEFT)
					) || (
						(map[y][x + 1] & (Room.TRAP | Room.MOVER)) && (map[y][x + 1] & Room.M_LEFT)
					)
				) && !(map[y][x + 1] & (Room.GENERATOR | Room.VIRUS))) ||
				(y < height - 1 && (map[y + 1][x] & Room.ENEMY) && (
					(
						(map[y + 1][x] & Room.TURNER) && (map[y + 1][x] & Room.UP)
					) || (
						(map[y + 1][x] & (Room.TRAP | Room.MOVER)) && (map[y + 1][x] & Room.M_UP)
					)
				) && !(map[y + 1][x] & (Room.GENERATOR | Room.VIRUS))) ||
				(x > 0 && (map[y][x - 1] & Room.ENEMY) && (
					(
						(map[y][x - 1] & Room.TURNER) && (map[y][x - 1] & Room.RIGHT)
					) || (
						(map[y][x - 1] & (Room.TRAP | Room.MOVER)) && (map[y][x - 1] & Room.M_RIGHT)
					)
				) && !(map[y][x - 1] & (Room.GENERATOR | Room.VIRUS)))
			);
		}
		
		/* Check if a player movement would be blocked */
		public function blockedDir(dir:int):Boolean{
			return Boolean(
				(dir == Room.UP && (player.y == 0 || ((map[player.y - 1][player.x] & (Room.WALL | Room.VOID)) && !(map[player.y - 1][player.x] & Room.SWAP)))) ||
				(dir == Room.RIGHT && (player.x == width - 1 || ((map[player.y][player.x + 1] & (Room.WALL | Room.VOID)) && !(map[player.y][player.x + 1] & Room.SWAP)))) ||
				(dir == Room.DOWN && (player.y == height - 1 || ((map[player.y + 1][player.x] & (Room.WALL | Room.VOID)) && !(map[player.y + 1][player.x] & Room.SWAP)))) ||
				(dir == Room.LEFT && (player.x == 0 || ((map[player.y][player.x - 1] & (Room.WALL | Room.VOID)) && !(map[player.y][player.x - 1] & Room.SWAP))))
			);
		}
		
		public function copy():LevelData{
			var level:LevelData = new LevelData(room, width, height);
			level.copyData(this);
			return level;
		}
		
		/* Deep copy */
		public function copyData(source:LevelData):void{
			var r:int, c:int;
			for(r = 0; r < height; r++){
				for(c = 0; c < width; c++){
					map[r][c] = source.map[r][c];
				}
			}
			playerDir = source.playerDir;
			player.x = source.player.x;
			player.y = source.player.y;
		}
		
		public function saveData(saveFood:Boolean = false):Object{
			var obj:Object = saveObject(width, height);
			obj.player.x = player.x;
			obj.player.y = player.y;
			if(saveFood) obj.food = food;
			if(room.type == Room.ADVENTURE){
				obj.endingDist = room.endingDist;
				obj.turns = turns;
			}
			var r:int, c:int;
			for(r = 0; r < height; r++){
				for(c = 0; c < width; c++){
					obj.map[r][c] = map[r][c];
				}
			}
			return obj;
		}
		
		/* Creates a template for saving data */
		public static function saveObject(width:int, height:int):Object{
			var obj:Object = {
				map:[],
				playerDir:Room.UP,
				player:{x:(width * 0.5) >> 0, y:(height * 0.5) >> 0}
			}
			var r:int, c:int;
			for(r = 0; r < height; r++){
				obj.map[r] = [];
				for(c = 0; c < width; c++){
					obj.map[r][c] = Room.VOID;
				}
			}
			return obj;
		}
		
		public static function writeToObject(source:Object, target:Object, width:int, height:int):void{
			target.player.x = source.player.x;
			target.player.y = source.player.y;
			var r:int, c:int;
			for(r = 0; r < height; r++){
				for(c = 0; c < width; c++){
					target.map[r][c] = source.map[r][c];
				}
			}
		}
		
		public function loadData(obj:Object):void{
			food = FOOD_MAX;
			if(obj){
				var r:int, c:int;
				for(r = 0; r < height; r++){
					for(c = 0; c < width; c++){
						map[r][c] = obj.map[r][c];
					}
				}
				playerDir = obj.playerDir;
				player.x = obj.player.x;
				player.y = obj.player.y;
				if(obj.food) food = obj.food;
				if(room.type == Room.ADVENTURE){
					room.endingDist = obj.endingDist;
					turns = obj.turns;
				}
			} else {
				room.clear();
				room.copyTo(map, 0, 0);
				player.x = room.startX;
				player.y = room.startY;
			}
			map[player.y][player.x] = Room.PLAYER | Room.ALLY;
		}
		
		/* Is a given move empty? */
		public function empty(x:int, y:int, dir:int):Boolean{
			if(dir == Room.UP){
				return y > 0 && map[y - 1][x] == Room.EMPTY;
			} else if(dir == Room.RIGHT){
				return x < width - 1 && map[y][x + 1] == Room.EMPTY;
			} else if(dir == Room.DOWN){
				return y < height - 1 && map[y + 1][x] == Room.EMPTY;
			} else if(dir == Room.LEFT){
				return x > 0 && map[y][x - 1] == Room.EMPTY;
			}
			return false;
		}
		
		public function swap(sx:int, sy:int, tx:int, ty:int):void{
			var source:int = map[sy][sx];
			var target:int = map[ty][tx];
			source &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.BLOCKED);
			target &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.BLOCKED);
			if(tx > sx){
				source |= Room.RIGHT;
				target |= Room.LEFT;
			} else if(tx < sx){
				source |= Room.LEFT;
				target |= Room.RIGHT;
			} else if(ty > sy){
				source |= Room.DOWN;
				target |= Room.UP;
			} else if(ty < sy){
				source |= Room.UP;
				target |= Room.DOWN;
			}
			map[ty][tx] = source;
			map[sy][sx] = target;
			if(Boolean(swapCallback)) swapCallback(tx, ty, target);
		}
		
		/* Recursive destruction - BOMB properties trigger this method when killed */
		public function explode(x:int, y:int, dir:int, explosion:int = 1):void{
			var oppositeDir:int = Room.oppositeDirection(dir);
			if(y > 0 && !(map[y - 1][x] & (Room.INDESTRUCTIBLE | Room.VOID | Room.DOOR)) && !(oppositeDir & Room.UP)){
				kill(x, y - 1, Room.UP, explosion + 1);
			}
			if(x < width - 1 && !(map[y][x + 1] & (Room.INDESTRUCTIBLE | Room.VOID | Room.DOOR)) && !(oppositeDir & Room.RIGHT)){
				kill(x + 1, y, Room.RIGHT, explosion + 1);
			}
			if(y < height - 1 && !(map[y + 1][x] & (Room.INDESTRUCTIBLE | Room.VOID | Room.DOOR)) && !(oppositeDir & Room.DOWN)){
				kill(x, y + 1, Room.DOWN, explosion + 1);
			}
			if(x > 0 && !(map[y][x - 1] & (Room.INDESTRUCTIBLE | Room.VOID | Room.DOOR)) && !(oppositeDir & Room.LEFT)){
				kill(x - 1, y, Room.LEFT, explosion + 1);
			}
		}
		
		/* Move an element one tile in a direction on the map - blocked movement is recorded */
		public function move(x:int, y:int, dir:int, friendly:int):Point{
			// store without a direction and set direction
			var property:int = map[y][x];
			if((property & Room.TURNER) && !(property & Room.GENERATOR) && (property & Room.UP_DOWN_LEFT_RIGHT)){
				property &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
				if(property & Room.UP) property |= Room.M_UP;
				else if(property & Room.RIGHT) property |= Room.M_RIGHT;
				else if(property & Room.DOWN) property |= Room.M_DOWN;
				else if(property & Room.LEFT) property |= Room.M_LEFT;
				property &= ~(Room.UP_DOWN_LEFT_RIGHT);
			}
			property |= dir;
			map[y][x] = property;
			var target:int;
			map[y][x] |= Room.BLOCKED;
			// if the way is clear, load the space with property unblocked or mark as attacking
			if(dir == Room.UP){
				if(y > 0){
					target = map[y - 1][x];
					if(property & Room.GENERATOR){
						if(target == Room.EMPTY && (property & Room.TIMER_0)){
							map[y - 1][x] = (property & ~(Room.GENERATOR | Room.UP_DOWN_LEFT_RIGHT)) | Room.UP | ((property & Room.TURNER) ? Room.M_UP : 0);
							if(property & Room.VIRUS) map[y - 1][x] |= Room.GENERATOR;
							map[y][x] = (property & ~(Room.UP_DOWN_LEFT_RIGHT)) | Room.UP | Room.ATTACK;
							if(Boolean(generateCallback)) generateCallback(x, y);
						} else {
							map[y][x] = property;
						}
					} else if((property & Room.TURNER) && !(property & Room.M_UP)){
						map[y][x] = property;
					} else if((property & Room.PLAYER) && (target & Room.SWAP)){
						swap(x, y, x, y - 1);
						y--;
					} else if(target & Room.WALL){
						// blocked
					} else if(target == Room.EMPTY){
						map[y - 1][x] = property;
						map[y][x] = Room.EMPTY;
						y--;
					} else if((target & (Room.ENEMY | Room.ALLY)) && !(target & friendly)){
						if(property & Room.WALL){
							map[y][x] = property;
							push(x, y, Room.UP);
							y--;
						} else {
							map[y][x] = (property | Room.ATTACK) + ((target & Room.PLAYER) ? Room.KILLER : 0);
							kill(x, y - 1, Room.UP);
						}
					}
					
				}
			} else if(dir == Room.RIGHT){
				if(x < width - 1){
					target = map[y][x + 1]
					if(property & Room.GENERATOR){
						if(target == Room.EMPTY && (property & Room.TIMER_0)){
							map[y][x + 1] = (property & ~(Room.GENERATOR | Room.UP_DOWN_LEFT_RIGHT)) | Room.RIGHT | ((property & Room.TURNER) ? Room.M_RIGHT : 0);
							if(property & Room.VIRUS) map[y][x + 1] |= Room.GENERATOR;
							map[y][x] = (property & ~(Room.UP_DOWN_LEFT_RIGHT)) | Room.RIGHT | Room.ATTACK;
							if(Boolean(generateCallback)) generateCallback(x, y);
						} else {
							map[y][x] = property;
						}
					} else if((property & Room.TURNER) && !(property & Room.M_RIGHT)){
						map[y][x] = property;
					} else if((property & Room.PLAYER) && (target & Room.SWAP)){
						swap(x, y, x + 1, y);
						x++;
					} else if(target & Room.WALL){
						// blocked
					} else if(target == Room.EMPTY){
						map[y][x + 1] = property;
						map[y][x] = Room.EMPTY;
						x++;
					} else if((target & (Room.ENEMY | Room.ALLY)) && !(target & friendly)){
						if(property & Room.WALL){
							map[y][x] = property;
							push(x, y, Room.RIGHT);
							x++;
						} else {
							map[y][x] = (property | Room.ATTACK) + ((target & Room.PLAYER) ? Room.KILLER : 0)
							kill(x + 1, y, Room.RIGHT);
						}
					}
				}
			} else if(dir == Room.DOWN){
				if(y < height - 1){
					target = map[y + 1][x];
					if(property & Room.GENERATOR){
						if(target == Room.EMPTY && (property & Room.TIMER_0)){
							map[y + 1][x] = (property & ~(Room.GENERATOR | Room.UP_DOWN_LEFT_RIGHT)) | Room.DOWN | ((property & Room.TURNER) ? Room.M_DOWN : 0);
							if(property & Room.VIRUS) map[y + 1][x] |= Room.GENERATOR;
							map[y][x] = (property & ~(Room.UP_DOWN_LEFT_RIGHT)) | Room.DOWN | Room.ATTACK;
							if(Boolean(generateCallback)) generateCallback(x, y);
						} else {
							map[y][x] = property;
						}
					} else if((property & Room.TURNER) && !(property & Room.M_DOWN)){
						map[y][x] = property;
					} else if((property & Room.PLAYER) && (target & Room.SWAP)){
						swap(x, y, x, y + 1);
						y++;
					} else if(target & Room.WALL){
						// blocked
					} else if(target == Room.EMPTY){
						map[y + 1][x] = property;
						map[y][x] = Room.EMPTY;
						y++;
					} else if((target & (Room.ENEMY | Room.ALLY)) && !(target & friendly)){
						if(property & Room.WALL){
							map[y][x] = property;
							push(x, y, Room.DOWN);
							y++;
						} else {
							map[y][x] = (property | Room.ATTACK) + ((target & Room.PLAYER) ? Room.KILLER : 0);
							kill(x, y + 1, Room.DOWN);
						}
					}
				}
			} else if(dir == Room.LEFT){
				if(x > 0){
					target = map[y][x - 1];
					if(property & Room.GENERATOR){
						if(target == Room.EMPTY && (property & Room.TIMER_0)){
							map[y][x - 1] = (property & ~(Room.GENERATOR | Room.UP_DOWN_LEFT_RIGHT)) | Room.LEFT | ((property & Room.TURNER) ? Room.M_LEFT : 0);
							if(property & Room.VIRUS) map[y][x - 1] |= Room.GENERATOR;
							map[y][x] = (property & ~(Room.UP_DOWN_LEFT_RIGHT)) | Room.LEFT | Room.ATTACK;
							if(Boolean(generateCallback)) generateCallback(x, y);
						} else {
							map[y][x] = property;
						}
					} else if((property & Room.TURNER) && !(property & Room.M_LEFT)){
						map[y][x] = property;
					} else if((property & Room.PLAYER) && (target & Room.SWAP)){
						swap(x, y, x - 1, y);
						x--;
					} else if(target & Room.WALL){
						// blocked
					} else if(target == Room.EMPTY){
						map[y][x - 1] = property;
						map[y][x] = Room.EMPTY;
						x--;
					} else if((target & (Room.ENEMY | Room.ALLY)) && !(target & friendly)){
						if(property & Room.WALL){
							map[y][x] = property;
							push(x, y, Room.LEFT);
							x--;
						} else {
							map[y][x] = (property | Room.ATTACK) + ((target & Room.PLAYER) ? Room.KILLER : 0);
							kill(x - 1, y, Room.LEFT);
						}
					}
				}
			}
			return new Point(x, y);
		}
		
		/* An unstoppable movement from a property */
		public function push(x:int, y:int, dir:int, move:Boolean = true):void{
			// can we push?
			if(dir == Room.UP){
				if(y > 1 && map[y - 2][x] == Room.EMPTY){
					if(map[y - 1][x] & Room.PUSHED){
						if(map[y][x] & Room.TURNER) map[y][x] &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
						else map[y][x] &= ~(Room.UP_DOWN_LEFT_RIGHT);
						return;
					} else if(map[y - 1][x] & Room.PLAYER){
						playerPush = Room.compassPoints[Room.NORTH];
					}
					map[y - 1][x] &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.ATTACK);
					map[y - 2][x] = map[y - 1][x] | Room.PUSHED | Room.UP;
				} else {
					kill(x, y - 1, Room.UP);
				}
				if(move){
					map[y - 1][x] = map[y][x];
					map[y][x] = Room.EMPTY;
				} else {
					map[y - 1][x] = Room.EMPTY;
				}
				
			} else if(dir == Room.RIGHT){
				if(x < width - 3 && map[y][x + 2] == Room.EMPTY){
					if(map[y][x + 1] & Room.PUSHED){
						if(map[y][x] & Room.TURNER) map[y][x] &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
						else map[y][x] &= ~(Room.UP_DOWN_LEFT_RIGHT);
						return;
					} else if(map[y][x + 1] & Room.PLAYER){
						playerPush = Room.compassPoints[Room.EAST];
					}
					map[y][x + 1] &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.ATTACK);
					map[y][x + 2] = map[y][x + 1] | Room.PUSHED | Room.RIGHT;
				} else {
					kill(x + 1, y, Room.RIGHT);
				}
				if(move){
					map[y][x + 1] = map[y][x];
					map[y][x] = Room.EMPTY;
				} else {
					map[y][x + 1] = Room.EMPTY;
				}
				
			} else if(dir == Room.DOWN){
				if(y < height - 3 && map[y + 2][x] == Room.EMPTY){
					if(map[y + 1][x] & Room.PUSHED){
						if(map[y][x] & Room.TURNER) map[y][x] &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
						else map[y][x] &= ~(Room.UP_DOWN_LEFT_RIGHT);
						return;
					} else if(map[y + 1][x] & Room.PLAYER){
						playerPush = Room.compassPoints[Room.SOUTH];
					}
					map[y + 1][x] &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.ATTACK);
					map[y + 2][x] = map[y + 1][x] | Room.PUSHED | Room.DOWN;
				} else {
					kill(x, y + 1, Room.DOWN);
				}
				if(move){
					map[y + 1][x] = map[y][x];
					map[y][x] = Room.EMPTY;
				} else {
					map[y + 1][x] = Room.EMPTY;
				}
				
			} else if(dir == Room.LEFT){
				if(x > 1 && map[y][x - 2] == Room.EMPTY){
					if(map[y][x - 1] & Room.PUSHED){
						if(map[y][x] & Room.TURNER) map[y][x] &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
						else map[y][x] &= ~(Room.UP_DOWN_LEFT_RIGHT);
						return;
					} else if(map[y][x - 1] & Room.PLAYER){
						playerPush = Room.compassPoints[Room.WEST];
					}
					map[y][x - 1] &= ~(Room.UP_DOWN_LEFT_RIGHT | Room.ATTACK);
					map[y][x - 2] = map[y][x - 1] | Room.PUSHED | Room.LEFT;
				} else {
					kill(x - 1, y, Room.LEFT);
				}
				if(move){
					map[y][x - 1] = map[y][x];
					map[y][x] = Room.EMPTY;
				} else {
					map[y][x - 1] = Room.EMPTY;
				}
			}
			if(Boolean(pushCallback)) pushCallback(x, y, dir);
		}
		
		/* Wipe action data in an area - used to clear animation data */
		public function flushStatus(x:int, y:int, radius:int):Array{
			var list:Array = [];
			var fromX:int = x - radius;
			var fromY:int = y - radius;
			var length:int = 1 + radius * 2;
			var toX:int = fromX + length;
			var toY:int = fromY + length;
			var r:int, c:int, property:int;
			for(r = fromY; r < toY; r++){
				for(c = fromX; c < toX; c++){
					if(c >= 0 && r >= 0 && c < width && r < height){
						// preserve a turner's previous direction
						property = map[r][c];
						if(!(property & Room.TURNER)) property &= ~(Room.UP_DOWN_LEFT_RIGHT);
						else property &= ~(Room.M_UP_DOWN_LEFT_RIGHT);
						property &= ~(Room.ATTACK | Room.BLOCKED | Room.PUSHED);
						map[r][c] = property;
					}
				}
			}
			return list;
		}
		
		public function moveEntities(list:Array):void{
			var i:int, j:int, target:Point = new Point();
			var px:int, py:int;
			var mx:int, my:int;
			var nodes:Array = [];
			var dir:int;
			var best:int;
			var value:int;
			var property:int;
			var dest:int;
			var type:int;
			var friendly:int;
			var p:Point;
			playerPush = null;
			//trace("list", list);
			for(i = 0; i < list.length; i++){
				p = list[i];
				mx = p.x;
				my = p.y;
				property = map[my][mx];
				// any entity that has already moved must be the player or has been swapped - forfeiting their turn
				// viruses cannot move without a generator
				if(
					property == 0 ||
					((property & Room.ALLY) && (property & Room.UP_DOWN_LEFT_RIGHT)) ||
					(property & (Room.VIRUS | Room.GENERATOR)) == Room.VIRUS
				){
					continue;
				}
				friendly = property & (Room.ALLY | Room.ENEMY);
				type = property & (Room.VIRUS | Room.MOVER | Room.TURNER | Room.TRAP | Room.ALLY);
				px = mx - (player.x - ENEMY_ACTIVE_RADIUS);
				py = my - (player.y - ENEMY_ACTIVE_RADIUS);
				best = int.MAX_VALUE;
				dir = 0;
				// advance timers
				if(property & Room.GENERATOR){
					property = Room.rotateBits(property, 1, Room.TIMER_MASK, 4);
					map[my][mx] = property;
				}
				if(type & Room.ALLY){
					if((playerDir & Room.UP) && my > 0 && !(map[my - 1][mx] & Room.DOOR)){
						p = move(mx, my, Room.UP, friendly);
					} else if((playerDir & Room.RIGHT) && mx < width - 1 && !(map[my][mx + 1] & Room.DOOR)){
						p = move(mx, my, Room.RIGHT, friendly);
					} else if((playerDir & Room.DOWN) && my < height - 1 && !(map[my + 1][mx] & Room.DOOR)){
						p = move(mx, my, Room.DOWN, friendly);
					} else if((playerDir & Room.LEFT) && mx > 0 && !(map[my][mx - 1] & Room.DOOR)){
						p = move(mx, my, Room.LEFT, friendly);
					}
					if((map[p.y][p.x] & Room.BLOCKED) && Boolean(blockedCallback)){
						blockedCallback(p.x, p.y, playerDir);
					}
				} else if((type & Room.TRAP) && !(property & Room.GENERATOR)){
					// traps just hit the player when they are next to their m_dirs
					if((property & Room.M_UP) && my > 0 && (map[my - 1][mx] & Room.ALLY)){
						move(mx, my, Room.UP, friendly);
					} else if((property & Room.M_RIGHT) && mx < width - 1 && (map[my][mx + 1] & Room.ALLY)){
						move(mx, my, Room.RIGHT, friendly);
					} else if((property & Room.M_DOWN) && my < height - 1 && (map[my + 1][mx] & Room.ALLY)){
						move(mx, my, Room.DOWN, friendly);
					} else if((property & Room.M_LEFT) && mx > 0 && (map[my][mx - 1] & Room.ALLY)){
						move(mx, my, Room.LEFT, friendly);
					}
				} else {
					if(py > 0 && my > 0){
						value = pathMap[py - 1][px];
						dest = map[my - 1][mx];
						if(
							my > 0 &&
							!(dest & (Room.WALL | friendly)) &&
							value != PATH_WALL && value < best &&
							!((type & Room.MOVER) && !(property & Room.M_UP))
						){
							dir = Room.UP;
							//trace("UP", value);
							best = value;
						}
					}
					if(px < PATH_MAP_SIZE - 1 && mx < width - 1){
						value =  pathMap[py][px + 1];
						dest = map[my][mx + 1];
						if(
							mx < width - 1 &&
							!(dest & (Room.WALL | friendly)) &&
							value != PATH_WALL && value < best &&
							!((type & Room.MOVER) && !(property & Room.M_RIGHT))
						){
							dir = Room.RIGHT;
							//trace("RIGHT", value);
							best = value;
						}
					}
					if(py < PATH_MAP_SIZE - 1 && my < height - 1){
						value = pathMap[py + 1][px];
						dest = map[my + 1][mx];
						if(
							my < height - 1 &&
							!(dest & (Room.WALL | friendly)) &&
							value != PATH_WALL && value < best &&
							!((type & Room.MOVER) && !(property & Room.M_DOWN))
						){
							dir = Room.DOWN;
							//trace("DOWN", value);
							best = value;
						}
					}
					if(px > 0 && mx > 0){
						value = pathMap[py][px - 1];
						dest = map[my][mx - 1];
						if(
							mx > 0 &&
							!(dest & (Room.WALL | friendly)) &&
							value != PATH_WALL && value < best &&
							!((type & Room.MOVER) && !(property & Room.M_LEFT))
						){
							dir = Room.LEFT;
							//trace("LEFT", value);
							best = value;
						}
					}
					if(dir){
						move(mx, my, dir, friendly);
					}
				}
			}
			// we have to buffer player pushes
			if(playerPush){
				player.x += playerPush.x;
				player.y += playerPush.y;
				playerPush = null;
			}
		}
		
		/* Fills the pathMap via wave propagation */
		public function fillPathMap(x:int, y:int, points:Array = null, find:int = 0, findList:Array = null, ignore:int = 0):void{
			var mx:int = x, my:int = y;
			var px:int, py:int;
			var i:int, d:int = 0, p:Point;
			Room.fill(0, 0, PATH_MAP_SIZE, PATH_MAP_SIZE, pathMap, PATH_WALL);
			if(!points){
				points = [new Point(ENEMY_ACTIVE_RADIUS, ENEMY_ACTIVE_RADIUS)];
				pathMap[ENEMY_ACTIVE_RADIUS][ENEMY_ACTIVE_RADIUS] = 0;
			} else {
				// reposition points to pathMap
				i = points.length;
				//trace("");
				//trace(points);
				while(i--){
					p = points[i];
					if(map[p.y][p.x] & (Room.WALL | Room.VOID)){
						points.splice(i, 1);
						continue;
					}
					p = new Point(p.x - (player.x - ENEMY_ACTIVE_RADIUS), p.y - (player.y - ENEMY_ACTIVE_RADIUS));
					if(p.x < 0 || p.y < 0 || p.x >= PATH_MAP_SIZE || p.y >= PATH_MAP_SIZE){
						points.splice(i, 1);
						continue;
					}
					points[i] = p;
					pathMap[p.y][p.x] = 0;
				}
			}
			var length:int = points.length;
			// ah le double while loop - makes its point though dunnit?
			while(length){
				while(length--){
					p = points.shift();
					px = p.x;
					py = p.y;
					mx = x + px - ENEMY_ACTIVE_RADIUS;
					my = y + py - ENEMY_ACTIVE_RADIUS;
					if(my > 0 && py > 0){
						if(pathMap[py - 1][px] == PATH_WALL){
							if(!(map[my - 1][mx] & (Room.WALL | Room.VOID))){
								points.push(new Point(px, py - 1));
							}
							if(find && findList){
								if((map[my - 1][mx] & find) && !(map[my - 1][mx] & ignore)){
									findList.push(new Point(mx, my - 1));
								}
							}
							pathMap[py - 1][px] = d + 1;
						}
					}
					if(mx < width - 1 && px < PATH_MAP_SIZE - 1){
						if(pathMap[py][px + 1] == PATH_WALL){
							if(!(map[my][mx + 1] & (Room.WALL | Room.VOID))){
								points.push(new Point(px + 1, py));
							}
							if(find && findList){
								if((map[my][mx + 1] & find) && !(map[my][mx + 1] & ignore)){
									findList.push(new Point(mx + 1, my));
								}
							}
							pathMap[py][px + 1] = d + 1;
						}
					}
					if(my < height - 1 && py < PATH_MAP_SIZE - 1){
						if(pathMap[py + 1][px] == PATH_WALL){
							if(!(map[my + 1][mx] & (Room.WALL | Room.VOID))){
								points.push(new Point(px, py + 1));
							}
							if(find && findList){
								if((map[my + 1][mx] & find) && !(map[my + 1][mx] & ignore)){
									findList.push(new Point(mx, my + 1));
								}
							}
							pathMap[py + 1][px] = d + 1;
						}
					}
					if(mx > 0 && px > 0){
						if(pathMap[py][px - 1] == PATH_WALL){
							if(!(map[my][mx - 1] & (Room.WALL | Room.VOID))){
								points.push(new Point(px - 1, py));
							}
							if(find && findList){
								if((map[my][mx - 1] & find) && !(map[my][mx - 1] & ignore)){
									findList.push(new Point(mx - 1, my));
								}
							}
							pathMap[py][px - 1] = d + 1;
						}
					}
				}
				length = points.length;
				d++;
			}
		}
		
		/* Called when killing a property at a tile - killCallback must accept the location and direction */
		public function kill(x:int, y:int, dir:int, explosion:int = 0):void{
			var property:int = map[y][x];
			// player receives food for kills next to them
			var vx:int = x - player.x;
			var vy:int = y - player.y;
			if(
				(vx == 0 && (vy == 1 || vy == -1)) ||
				(vy == 0 && (vx == 1 || vx == -1))
			){
				food += FOOD_KILL;
				if(food > FOOD_MAX) food = FOOD_MAX;
			}
			// doors create new rooms
			if(property & Room.DOOR){
				if(property & Room.ENDING){
					ending(x, y, dir);
				} else {
					var value:int = 0;
					if(property & Room.INCREMENT) value++;
					var p:Point = createRoom(x, y, dir, value);
					x = p.x;
					y = p.y;
				}
			}
			if(Boolean(killCallback)) killCallback(x, y, dir, property, explosion || ((property & Room.BOMB) ? 1 : 0));
			map[y][x] = Room.EMPTY;
			if(property & Room.BOMB){
				explode(x, y, dir, explosion);
			}
		}
		
		public function ending(x:int, y:int, dir:int):void{
			ended = true;
			if(Boolean(endingCallback)) endingCallback(x, y, dir);
		}
		
		/* Create a room adjacent to the one the player is in */
		public function createRoom(x:int, y:int, dir:int, dist:int):Point{
			var roomsWide:int = Math.ceil(width / room.width);
			var roomsHigh:int = Math.ceil(height / room.height);
			// current quadrant
			var qx:int = player.x / room.width;
			var qy:int = player.y / room.height;
			var qRect:Rectangle = new Rectangle((qx * room.width) - qx, (qy * room.width) - qy, room.width, room.height);
			// target quadrant
			var tx:int = qx;
			var ty:int = qy;
			if(dir == Room.UP) ty--;
			else if(dir == Room.RIGHT) tx++;
			else if(dir == Room.DOWN) ty++;
			else if(dir == Room.LEFT) tx--;
			// move current room if target out of bounds
			if(tx < 0 || tx >= roomsWide || ty < 0 || ty >= roomsHigh){
				playerPush = new Point();
				if(ty < 0){
					qy++;
					ty++;
					y += room.height - 1;
					playerPush.y += room.height - 1;
				} else if(tx >= roomsWide){
					qx--;
					tx--;
					x -= room.width - 1;
					playerPush.x -= room.width - 1;
				} else if(ty >= roomsHigh){
					qy--;
					ty--;
					y -= room.height - 1;
					playerPush.y -= room.height - 1;
				} else if(tx < 0){
					qx++;
					tx++;
					x += room.width - 1;
					playerPush.x += room.width - 1;
				}
				//trace("moved to", qx, qy, tx, ty);
				//trace("at", (qx * room.width) - qx, (qy * room.width) - qy);
				Room.copyRectTo(map, qRect, map, (qx * room.width) - qx, (qy * room.height) - qy, copyBuffer);
			}
			// erase unused side
			var revealDir:int;
			var eraseDir:int;
			if(qx == tx){
				if(qx == 0) eraseDir = Room.EAST;
				else if(qx == 1) eraseDir = Room.WEST;
				if(qy == 0) revealDir = Room.SOUTH;
				else if(qy == 1) revealDir = Room.NORTH;
			} else if(qy == ty){
				if(qy == 0) eraseDir = Room.SOUTH;
				else if(qy == 1) eraseDir = Room.NORTH;
				if(qx == 0) revealDir = Room.EAST;
				else if(qx == 1) revealDir = Room.WEST;
			}
			if(Boolean(displaceCallback)){
				var pushX:int, pushY:int;
				if(playerPush){
					pushX = playerPush.x;
					pushY = playerPush.y;
				}
				displaceCallback(pushX, pushY, revealDir, eraseDir);
			}
			
			if(eraseDir == Room.NORTH) Room.fill(0, 0, width, room.height - 1, map, Room.VOID);
			else if(eraseDir == Room.EAST) Room.fill(room.width, 0, room.width - 1, height, map, Room.VOID);
			else if(eraseDir == Room.SOUTH) Room.fill(0, room.height, width, room.height - 1, map, Room.VOID);
			else if(eraseDir == Room.WEST) Room.fill(0, 0, room.width - 1, height, map, Room.VOID);
			// create and paste
			room.endingDist -= dist;
			if(room.endingDist < 1) room.endingDist = 1;
			if(room.endingDist > Room.DIST_TO_ENDING) room.endingDist = Room.DIST_TO_ENDING;
			room.init(new Point(x - ((qx * room.width) - qx), y - ((qy * room.height) - qy)), revealDir);
			room.copyTo(map, (tx * room.width) - tx, (ty * room.height) - ty);
			return new Point(x, y);
		}
		
		/* Create a mask for hiding unvisitable parts of a puzzle level
		 * wave propagation used here to spread visibility from the Ending and stopping on indestrucible walls */
		public function getBlackOutMap():Array{
			// get ending position
			var endings:Array = [];
			Room.setPropertyLocations(0, 0, width, height, map, Room.ENDING, endings);
			if(endings.length == 0) return null;
			var i:int, x:int, y:int;
			var p:Point = new Point(endings[0].x, endings[0].y);
			var blackOutMap:Array = Room.create2DArray(width, height, 0);
			var points:Array = [p];
			var length:int = points.length;
			blackOutMap[p.y][p.x] = 1;
			while(length){
				while(length--){
					p = points.shift();
					x = p.x;
					y = p.y;
					if(map[y][x] & Room.INDESTRUCTIBLE) continue;
					// cardinals
					if(y > 0 && blackOutMap[y - 1][x] == 0){
						points.push(new Point(x, y - 1));
						blackOutMap[y - 1][x] = 1;
					}
					if(x < width - 1 && blackOutMap[y][x + 1] == 0){
						points.push(new Point(x + 1, y));
						blackOutMap[y][x + 1] = 1;
					}
					if(y < height - 1 && blackOutMap[y + 1][x] == 0){
						points.push(new Point(x, y + 1));
						blackOutMap[y + 1][x] = 1;
					}
					if(x > 0 && blackOutMap[y][x - 1] == 0){
						points.push(new Point(x - 1, y));
						blackOutMap[y][x - 1] = 1;
					}
					// corners
					if(y > 0 && x > 0 && blackOutMap[y - 1][x - 1] == 0){
						points.push(new Point(x - 1, y - 1));
						blackOutMap[y - 1][x - 1] = 1;
					}
					if(y > 0 && x < width - 1 && blackOutMap[y - 1][x + 1] == 0){
						points.push(new Point(x + 1, y - 1));
						blackOutMap[y - 1][x + 1] = 1;
					}
					if(y < height - 1 && x < width - 1 && blackOutMap[y + 1][x + 1] == 0){
						points.push(new Point(x + 1, y + 1));
						blackOutMap[y + 1][x + 1] = 1;
					}
					if(y < height - 1 && x > 0 && blackOutMap[y + 1][x - 1] == 0){
						points.push(new Point(x - 1, y + 1));
						blackOutMap[y + 1][x - 1] = 1;
					}
				}
				length = points.length;
			}
			
			// if the player is blacked-out, the blackout map is useless
			if(blackOutMap[player.y][player.x] == 0) return null;
			
			return blackOutMap;
		}
		
		public static function printPathMap():void{
			var r:int, c:int, str:String;
			var size:int = pathMap.length;
			var line:String;
			for(r = 0; r < size; r++){
				line = "";
				for(c = 0; c < size; c++){
					str = pathMap[r][c] + "";
					if(str.length < 2) str = "0" + str;
					if(c < size - 1) str += ",";
					line += str;
				}
				trace(line);
			}
			trace("");
		}
		
	}

}